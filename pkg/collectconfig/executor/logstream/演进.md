# 版本1
1. 基于拉模式, 完全不考虑任何复用, 每个logstream完全独立, 简单但会造成同一个文件重复读取

# 版本2
1. 在版本1的基础上, 模仿sls, 用户使用一个cursor不停拉取, 服务端产生串行读之后对应一个cursor并缓存下来, 缓存最近一段时间的cursor的结果
2. 缺点是缓存的时间不好控制, 太短会导致后面读不到, 太长会导致浪费内存

# 版本2.1
1. 在版本2的基础上引入监听机制, 每个cursor从诞生之初就知道它应该被多少次读取, 这样通过一个计数器就知道该cursor是否已经被消费完, 一旦消费完就立即释放
2. 监听器用于通知消费者有新的cursor可以消费, 仅此而已
3. 新增的监听器只会影响之后新产生的cursor
4. 删除的监听器会立即使用之前cursor的引用, 从而防止短时间内的内存泄漏

# 版本3
1. 引入一个中间层, 它使用拉模式从input读数据
2. 读数据的实际取决于该中间层涉及的所有消费者(5秒级/秒级)
3. 中间层拉到数据使用, 调用每个consumer的方法进行串行消费
4. 缺点: 不太方便实现多文件采集

# 版本4
1. 中间层使用拉模式从input读数据, 然后推给每个consumer的chan
2. 基于推模式, 推送给所有consumer的chan, 但对于input来说它还是被动的拉模式, 中间引入一个代理层做到而已
3. 每个consumer可以调用代理层从而立即触发一次日志读取并推送(注意此处的并发处理)
4. consumer 更新时该chan要继承
5. 使用基于时间的emit

# 期望的多文件采集的工作方式
1. 日志源封装, 不管是单个文件还是多个文件都收敛在这里
2. 消费者, 真正的消费逻辑, 一般它只会被串行访问, 使用'外部同步'
3. 协调器, 协调日志源于消费者, 一般来说它负责构建日志源, 感应日志源的变化, 从日志源拉数据, 然后传递给消费者
4. 多个日志源的封装也可以不封装, 由协调器去协调多个独立的日志源, 这样的好处是可以提高单个日志源的复用率

# 最终版
1. 基本概念
   1. 采集任务
   2. 消费者(简称c): 一个采集任务对应一个消费者来执行它的聚合逻辑
   3. 日志源感应器
   4. 日志源
   5. 日志源管理器
   6. pipeline(简称p): 负责运行一个采集任务, 包含 日志源感应器/多个日志源/消费者
2. 运行流程
   1. 每个任务有一个独立的p, p使用日志源感应器得出该任务涉及哪些日志源, 使用日志源管理器获取这些日志源从而实现日志源在多个p之间的共享
   2. 任务发生更新时整个过程是原子的, 暂停旧p, 新建p, 新p从旧p继承一些状态, 启动新p
   3. 或者p能实现原地更新那也行, 只是新建的方式应该更干净一点
   4. p根据t的特性, 定期从多个日志源拉取日志, 然后调用t进行消费
